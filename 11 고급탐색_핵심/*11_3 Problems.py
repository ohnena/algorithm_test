# 백준온라인 1766
# 이문제는 위상정렬 + 최소힙의 콜라보 문제다.... (ㅠㅠ 위상정렬이 뭔지조차 몰랐다...)
# 시간관계상 제출은 안하고 우선 분석만 하고 넘어가도록한다. 2020.5.12.


# 해답 분석...
import heapq


# 1 그래프, 인디그리배열 생성 ..
n, m = map(int, input().split())
array = [[] for i in range(n + 1)]  # 리스트 내 리스트로 그래프를 구현...
indegree = [0] * (n + 1)            # 노드들 개별 indegree를 따로 관리한다. (위상정렬알고리즘에 필요하기때문)
heap = []
result = []

# 2 그래프, 인디그리배열 세팅 ..
for _ in range(m):
    x, y = map(int, input().split())
    array[x].append(y)
    indegree[y] += 1

# <<<< 위상정렬 알고리즘 시작… >>>>




# 3 (사전준비-힙세팅) 인디그리가 0인 노드를 힙에 넣기 … (heapq는 디폴트로 minheap으로 동작하지..자세한건 heqpq 메모해둔거참고)
for i in range(1, n + 1):
    if indegree[i] == 0:
        heapq.heappush(heap, i)


# 4 위상정렬 알고리즘 동작!…팝한녀석을 기록해두고 그거로부터 들어가는 indegree정보를 수정. 0이되면 힙에 push…그리고나서 힙이 빌때까지 다시 반복..
result = []
while heap:
    data = heapq.heappop(heap)
    result.append(data)
    for y in array[data]:
        indegree[y] -= 1
        if indegree[y] == 0:
            heapq.heappush(heap, y)

for i in result:
    print(i, end=' ')





# 해답   //위상정렬 매커니즘 이용한 문제....medium...

import heapq
n, m = map(int, input().split())
array = [[] for i in range(n + 1)]
indegree = [0] * (n + 1)
heap = []
result = []

for _ in range(m):
    x, y = map(int, input().split())
    array[x].append(y)
    indegree[y] += 1

for i in range(1, n + 1):
    if indegree[i] == 0:
        heapq.heappush(heap, i)

result = []
while heap:
    data = heapq.heappop(heap)
    result.append(data)
    for y in array[data]:
        indegree[y] -= 1
        if indegree[y] == 0:
            heapq.heappush(heap, y)

for i in result:
    print(i, end=' ')



# 강의메모를 아래 붙여넣어본다....

# 11.3 문제집
# 1766
# medium, 힙, 위상정렬, 40분
# //아 40분이나...아무것도 못하게만드네..
# //그보다 위상정렬은 또 뭐지?
#
# *핵심아이디어
# -전형적인 위상정렬(topology sort) 문제다. 위상정렬은 heap을 이용하면 쉽게 풀 수 있다.
# -위상정렬의 시간복잡도는 O(V+E)라고 한다
#
# 참고) 위상정렬알고리즘의 매커니즘
# 1) 진입차수가 0인 정점을 큐에 삽입
# 2) 큐에서 원소를 꺼내 해당원소와 간선을 제거
# 3) 제거 이후에 진입 차수가 0이 된 정점을 큐에 삽입
# 4) 큐가 빌때까지 2)~3)의 과정을 반복.
# //이문제에선 큐를 minHeap으로 사용하면 되겠다..
#
# 주의!) 위상정렬알고리즘 사용시 '사이클'을 주의하라...
# -모든 원소를 방문하기전에 큐가 빈다면 사이클이 존재하는 것이다. 아직 방문할녀석들이 남았는데 큐에 넣을 녀석은 또 없는 상황이라면, indegree가 0인 노드가 없는 상황이니...
# //생각해보니 in/out degree얘기하는 건 이 모든게 "방향그래프"를 가정하는거구나!
# //꼭 유념하자...방향그래프에서 위상정렬을 이용해서 노드들을 방문하고있는데, 아직 방문할 녀석들이 잔뜩인데 indegree가 0인 녀석이 하나도 없다...그러면 백퍼 사이클이다... ###!!!
#
#
# *위상정렬 매커니즘을 이문제에 대입시켜보자..
# 예를들어 3->1, 4->2의 정보가 주어졌을때,
# 진입차수가 0인 노드는 3과 4이다. 둘을 최소힙에 넣고 minHeap[3,4], 팝을 하면 3이 나오는데 노드3과 간선을 제거한다. 그러면
# 1, 4->2의 상황이 된다. 이때 다시 진입차수가 0인
# 노드를 힙에 넣자. minHeap[1,4]가 된다. 팝을 하면 1이 나오고 노드1과 간선을 그래프에서 제거한다. 4->2만 남았다. 4를 힙에 넣고 팝하자. 팝한 노드4와 그것의 간선을 제거 하면
# 2만 남아서, 그걸 또 힙에 넣고 팝하면 문제가 종료된다.
# //이 문제의 특성상 되도록 수가 작은 문제를 먼저 해결해야하니, 큐 대신 min heap을 사용.
#
#
#
# 해답 코드를 보니,
# 1 input값을 받아와서 세팅하는 것부터 까다롭다.
# -n, m은 각각 문제의 총개수, 먼저해결해야할 문제 개수
# -연결정보를 담을 리스트에 대한  리스트인 array를 n+1길이만큼 초기화생성.
# -인디그리를 담을 리스트인 indegree를 n+1만큼 초기화생성.
# //참고로 n+1길이로 만든다는 것은 노드의 data값을 index로 사용하겠다는 의미.
#
# 2 본격적인 문제들의 관계정보를 input으로 받는다. (p1->p2 P1을 먼저풀어야 P2를 풀수 있게된다)
# -array[p1].append(p2) //문제간 관계 즉 노드간의 연결정보를 세팅해주자
# -indegree[p2] += 1 //인디그리를 increment해주자.
#
# (여기까지가 위상정렬 시작전 세팅. 이제 본격적으로 위상정렬 매커니즘을 시작해보자)
#
# 3 인디그리가 0인 노드들을 큐(여기선 최소힙)에 집어넣자
#
# 4 이제 힙이 빌때까지, while문을 돌린다
# -팝을 해서 그값은 result에 넣고(팝했다는 건 그 문제를 풀었다는 것이니.), 연결정보인 array에서 팝한 값에 대한 간선(연결정보)를 모두 삭제해주자. 그리고 간선이 사라지고나서 인디그리(indegree[y])가 0인 노드들은 다시 큐(여기선 최소힙)에 넣어주자.
#
# //heap이 빌때까지 while문이 돌아가서 result가 완성될 것이다.



#
# # 회고
# -직접코딩은 아직 안했지만, 그냥 놓칠까봐 회고부터 먼저하고 본다
# -이문제는 위상정렬에 관한 문제다. 위상정렬을 뭔가? topological sort?
# -topology라는 것에 대해서 찾아보니, 스타형,매쉬형,트리형 등의 네트워크 토폴로지가 나오더라. 즉 노드들과 간선으로 이루어진 네트워크 배열 혹은 구성을 .
#  쉽게 생각해서 그래프형태를 떠올리면 되겠다.
# -그렇다면 topological sort라는건 뭘까? 바로 그래프형태로 존재하는 데이터들을 sort하는 것을 말한다고 볼 수 있겠다.
# -위상정렬에서의 그래프는 DAG이다. directed acyclic graph. 방향성이 존재하면서도 사이클이 있으면 안되는.
# -방향성그래프에서 노드들이 어떠한 데이터(우선순위로써 작용)를 가졌다면, 이 그래프를 우리는 일종의 "작업의 순서도"로 볼 수 있겠다.
#  예를 들자면, A->B라면 A라는 작업이 선행되어야 B라는 작업도 할 수 있다.
# -그렇다 한마디로 위상정렬이라는건 "작업을 순서대로 수행하는 일"을 말한다. 그래프가 작업의 순서도이고, 노드가 작업, 간선이 작업의 순서를 표시한다
# -개요는 여기까지하고, 위상정렬의 매커니즘을 들여다보자
# -1) 최초에 DAG그래프에서 indegree가 없는 노드들을 큐에 insert한다
# -2) 큐에서 팝한 노드를 기록하고(첫번째로 수행되는 작업이겠지...팝한다는게 이런의미다), 거기에 연결된 노드들의 indegree를 -1한다. (팝한 노드는 그래프상에서 지워지는 것...)
# -3) 이때 indegree를 -1해서 0이되는 노드들은 다시 큐에 insert한다
# -4) 큐가 빌때까지 2)~3)을 반복한다. //단 큐에 여전히 노드가 남았는데 indegree가 0인녀석이 없다면, 그 그래프는 애초에 acyclic한 그래프가 아니라는 얘기이므로 알고리즘을 종료해야한다(무한루프일테니...)
#
# -매커니즘은 이정도로 하고, 이문제에서의 디테일한 구현을 조금 들여다보자
# -위상정렬의 매커니즘은 위의 내용 그대로고, 그전에 인풋을 받아서 그래프와 indegree정보를 세팅하는 부분이 인상적
# -그래프는 리스트에 대한 리스트로 구현한다. 그래프가 [[], [2,3,4], [5],[6],[],[],[]] 라면, 노드 1에 연결된 노드는 2,3,4가 된다
# -그리고 indegree정보도 리스트다. 위의 그래프대로라면, [0, 0, 1, 1, 1, 1, 1] 이런식이겠다...
# -최초 리스트 세팅하는 방식이 여전히 내겐 생소하다. 리스트내에서 for를 돌리거나 [0]에 수를 곱하는 방식...리스트컴프리헨션인가 이런것들도? (아래참고)
# array = [[] for i in range(n + 1)]
# indegree = [0] * (n + 1)