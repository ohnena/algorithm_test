# 유형별문제풀이>12 동적프로그래밍-기초
#
# //동적프로그래밍은 기업테스트에서도, 대회에서도 많이 나오는 단골...쉬운난이도부터 어려운난이도까지...
# //근데 동적프로그래밍이 뭐더라?
#
#
# 12.1 01타일
# 1904
# easy,동적프로그래밍,20분
# //가장 전형적인 동적프로그래밍 문제이면서 가장 쉬운...감잡는데 좋은 문제
#
# 핵심아이디어
# -N이 최대 백만(10^6=2^20)이므로 시간복잡도는 O(N)으로 끝내야한다. //NlogN이더라도.. 2천만연산이라...파이썬의 첫번째 마지노선이긴해...
# -Memorization을 하기 위해, 이미 구한 녀석들을 리스트에 넣어두든지 해야한다.
# -기본적으로 동적프로그래밍 문제를 풀기위해서는 점화식(인접한항들사이의 관계식)을 세워야한다!
# ex) 피보나치수열에서의 점화식은 F(n)=F(n-1)+F(n-2) 이겠구나
# -타일을 붙이는 구조상 점화식은 D[i] = D[i-1] + D[i-2]라고 할 수 있다. 왜냐하면 길이가 i인 타일을 만드는 방법은  i-1일때 1을 붙이는 경우와, i-2일때는 00을 붙이는 경우밖엔 없기때문이다.
# //헐...이건 피보나치수열의 점화식과 똑같네...이런 문제를 만들어낸 사람이 대단하다 -_-...




# 입력
# 첫 번째 줄에 자연수 N이 주어진다.(N ≤ 1,000,000)
#
# 출력
# 첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.
#
# 예제입력
# 4
#
# 예제출력
# 5


n = int(input())
# n = 4

d = [0] * 1000001 # for Memorization...
d[1] = 1 # 1
d[2] = 2 # 00, 11

for i in range(3, n+1):
    d[i] = (d[i-2] + d[i-1]) % 15746 # for Test...% operation...

print(d[n])

# assert d[n] is 5

# 확실히, %연산을 안해주면 숫자가 무지막지하게 올라가서 제출시에 메모리 초과가 뜬다. 그래서 문제자체에서 %연산을 요구...







#
# 뒤늦은 소회
# :
# <낼름 받아먹은 점화식에 대한 반성>
# 신기하게 기억에 없다. 이문제에서 내가 점화식을 어떻게 도출했는지 말이다. 보통 DP문제는 해설을 통해 그 진행과정을 한번봤다면,
# 조금이라도 점화식의 도출원리를 알고있어야하는데. 이건 신기하게 아무것도 남지 않았다.
# 문제만든 사람을 칭찬하고 있었던 내 기록을 보니, 이문제의 점화식이 왜 피보나치수열의 점화식과 같은지에 대한 신기함만을 표시하고있다.
# 아무래도 그냥 강사가 얘기해준 점화식을 낼름 받아먹고 끝냈나보다.
#
# <검색으로 찾아본 해설...그럴듯하지만 애매...>
# 검색을 좀해보니, 그나마 건진건
# d[n-1] + d[n-2] = d[n]이라는 점화식이 나온 원리를
# d[n-1]에 뒤에 00을 붙이고
# d[n-2]의 뒤에 1을 붙이면, 결국 d[n]의 모든 경우의 수가 된다고 얘기하더라. (직관적으로 딱 와닿진 않는다.)
#
# 이를 의심해서, 만약 d[n-1] 앞에 00을 붙여보면, 어김없이 d[n-2] 뒤에 1을 붙인 것과 겹쳐버린다.
# 왜 그럴까?
#
# <원리를 쥐어짜보았지만...역부족>
# 내 짧은 생각으로 대략의 원리를 풀어보기 위해 아래의 예를 생각해보았다.
#
# d[n-1]의 원소인 1과,
# d[n-2]의 원소인 00이 있다고 가정해보자. 이녀석들이 각각 d[n]이 되려고 자가증식했는데, 결국 겹치는게 발생해서 문제가 되는 시나리오다.
# 이 1과 00이 각각 d[n]이 되어 겹치는 케이스를 생각해보자.
# 1에는 앞뒤로 00을 붙여서 --> 00+1, 1+00  (겹치는 케이스를 생각하기위해 앞뒤로 11을 붙이는건 구상에서 제외...)
# 00에는 앞뒤로 1을 붙여서 --> 1+00, 00+1
#
# 그렇다. 서로 완전히 중복되어 버린다. 대각선으로 중복되어버리기 때문에, 이런경우에는 1에게는 너는 앞에 00을 붙여라. 00에게는 너는 뒤에 1을 붙여라고
# 요청하여, 중복을 막을 수 있겠다.
#
# 결론은 d[n-2]에게는 넌 뒤에 00을 붙여라, d[n-1]에게는 넌 뒤에 1을 붙여라. 혹은 반대로,
# d[n-2]에게는 넌 앞에 00을 붙여라, d[n-1]에게는 넌 앞에 1을 붙여라 라는 식으로 d[n]을 만들어낼 수 있다는 말이다
# (이렇게 같은 방향으로 붙이도록 유도하면, 신기하게 서로 겹치는 부분들이 서로 피해가더라.)
#
#
# <결론은 이건 케이스 자체를 기억하고 있어야할 듯 하다>
# 하아...이런 생각도 그냥 지푸라기라도 잡는 심정으로 구상해본것이다. 사실 딱 떨어지는 (직관적인) 설명을 못하겠다.
# 사실 이해를 못하고 있는데 설명을 어떻게 하겠나...
#
# 어쨌든 이런 1, 00을 이용한 조합의 문제는 피보나치수열의 점화식이 나온다는 정도만 기억하자...
